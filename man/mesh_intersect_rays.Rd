% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh_intersect_rays.R
\name{mesh_intersect_rays}
\alias{mesh_intersect_rays}
\title{Compute the mesh intersection points for a set of rays}
\usage{
mesh_intersect_rays(rays, mesh, parExec = FALSE, maxCores = NA)
}
\arguments{
\item{rays}{A non-empty matrix-like object (N x 6, where N is the number of
rays) containing (x,y,z) coordinates for the origin of the rays in the first
three columns and those for a second point along the ray in the last three
columns.}

\item{mesh}{A triangular mesh object (\code{mesh3d}).}

\item{parExec}{boolean indicating whether parallel processing is to be used.
Set to FALSE by default.}

\item{maxCores}{integer specifying the maximum number of cores to use if
parExec is set to TRUE. Requesting more cores than are physically available
will simply result in all cores being used. The parameter is set to NA by
default; if parExec is set to FALSE, this parameter will be ignored.}
}
\value{
A list of matrices (N' x 3, where N' is the number of intersections)
containing the coordinates for the intersection points for each ray. Each
list element corresponds to a ray, in input order.
}
\description{
Computes the intersection points between a mesh and a set of
non-directional rays
}
\note{
Parallel processing only starts making sense with 20 or more rays;
otherwise, it's faster to run with parallel processing disabled.
}
\examples{
data(demoFlake1)
alignedMesh <- Morpho::pcAlign(demoFlake1$mesh)
# Construct and cast some rays:
rays <- data.frame(x1 = c(-41.65845, -41.82012, -41.87693),
                   y1 = c(-1.22681434, -0.91828322, -0.41378155),
                   z1 = c(100, 100, 100))
rays$x2 <- rays$x1
rays$y2 <- rays$y1
rays$z2 <- rays$z1 - 1

mesh_intersect_rays(rays[1:3,], alignedMesh, parExec = FALSE)
}
