% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/edgeAngles_yezziwoodleyetal.R
\name{ea_yw}
\alias{ea_yw}
\title{Compute edge angles using Yezzi-Woodley et al.'s method}
\usage{
ea_yw(mesh, poi, radius = 3, lambda = 2)
}
\arguments{
\item{mesh}{A \code{mesh3d} object on which edge angles will be measured}

\item{poi}{A point of interest (i.e., POI) from which the edge angle will be
measured, represented as a 1X3 matrix-like object containing x, y, and z
coordinates.}

\item{radius}{A positive numeric value indicating the search radius from the
\code{poi} for including mesh vertices in the angle measurements (see details)}

\item{lambda}{A positive numeric value used as a tuning parameter for the
underlying clustering algorithm (see details)}
}
\value{
A list containing: 1) the cluster assignments (\code{C}) for vertices
included in the patch; 2) the IDs of those vertices in the input mesh object
(\code{patch_vertex_ids}), 3) the angles (\code{theta}) computed using surface normals
determined by a) PCA and b) simple averaging respectively; 4) the
aforementioned normals (\code{m1}, \code{m2}, \code{n1}, and \code{n2} respectively); and 5) a
goodness of fit value (\code{fit}).
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This is a partial implementation of the Virtual Goniometer algorithm
proposed by Yezzi-Woodley et al. (2021) for measuring edge angles on meshes.
It works by selecting a patch of mesh vertices (i.e., surface points) around
a user-specified point of interest (POI) and approximating two intersecting
planes within the patch.
}
\details{
This function and its helpers are a modified partial translation of
the C++ code developed by the \href{http://amaaze.umn.edu}{AMAAZE consortium} as
a Meshlab plugin \href{https://github.com/cnr-isti-vclab/meshlab-extra-plugins}{Meshlab extra plugins}.
The full details of how this function works can be found in \href{https://link.springer.com/article/10.1007\%2Fs12520-021-01335-y}{Yezzi-Woodley et al. (2021)}.
The main differences between this implementation and the original are:
\itemize{
\item This implementation only provides one way of specifying the measurement
point: the "xyz method" described in Yezzi-Woodley et al. (2021).
\item This implementation selects mesh surface points for the angle computations
using Euclidean rather than geodesic distances. Note that the results are
very similar whether geodesic or Euclidean distances are used (see Yezzi-Woodley et
al., 2021).
}
}
\examples{
# Load demo data
library(rgl)
mesh <- demoFlake2$mesh
mesh <- Rvcg::vcgUpdateNormals(mesh) # ensure normals are up to date

# Set a point where the angles will be measured. You can use the
# interactive mesh_mark_pois() to select this point, you can import
# its coordinates from another program (e.g., Meshlab), or you can specify
# its coordinates manually as done here:
poi <- data.frame(x = c(-20.1301), y = c(39.29581), z = c(413.7))

# Compute the edge angle at the set point using default parameters options
res <- ea_yw(mesh, poi)

# Visualize the angle measurement:
\dontrun{
shade3d(mesh, col = "green") # Show the mesh
points3d(poi, col = "yellow", size = 10) # show the POI

# Determine which mesh vertices where included in the patch
patch_coords <- t(mesh$vb)[res$patch_vertex_ids, ]

# Show the mesh vertices color-coded by the surface to which they were
# assigned by the clustering algorithm
points3d(patch_coords[which(res$C == 1), 1:3], col = "red") # Surface 1
points3d(patch_coords[which(res$C == 2), 1:3], col = "blue") # Surface 2

# Show the measurement plane for the first angle:
res_planes <- planeCoefs(rbind(poi, poi + res$m1, poi + res$m2))
planes3d(res_planes[1], res_planes[2], res_planes[3], res_planes[4],
         col="cyan")
}
}
\seealso{
\code{\link[=mesh_mark_pois]{mesh_mark_pois()}}, \code{\link[=drop_poi]{drop_poi()}}
}
\author{
Cornel M. Pop
}
