% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh_intersect_rays.R
\name{trace_ray}
\alias{trace_ray}
\title{Compute the intersection points of a ray and a set of triangles}
\usage{
trace_ray(o, d, v0, v1, v2, epsilon)
}
\arguments{
\item{o}{A non-empty matrix (N x 3) with the coordinate of the ray origin
repeated so that the number of rows (N) matches the number of triangles.}

\item{d}{A non-empty matrix (N x 3) object with the direction of the ray
(i.e. the difference between an arbitrary point along the line and the x, y,
and z coordinate of the ray's origin) repeated so that the number of rows (N)
matches the number of triangles.}

\item{v0}{A non-empty matrix (N x 3) object with the (x,y,z) coordinates of
the first vertex for each of the N triangles.}

\item{v1}{A non-empty matrix (N x 3) object with the (x,y,z) coordinates of
the second vertex for each of the N triangles.}

\item{v2}{A non-empty matrix (N x 3) object with the (x,y,z) coordinates of
the third vertex for each of the N triangles.}

\item{epsilon}{The floating point precision used to check whether the angle
formed by the ray and the plane of the triangles is +/- zero (i.e. whether
the ray is parallel).}
}
\value{
a (N x 3) matrix containing the coordinates of the intersection
points. If no intersections are found the output matrix will have zero rows.
}
\description{
Computes the intersection point(s) of a ray and an arbitrarily
large set of triangles using the algorithm of Moller and Trumbore (1997).
}
\note{
This function was inspired by the Matlab toolbox developed by Jaroslaw
Tuszynski (2011-2014). In theory this function can be used as-is to test the
intersection of multiple rays/multiple triangles, but in practice doing so
requires much more memory (nr. triangles * nr. rays) and offers very marginal
improvements in execution speed.
}
\examples{
ray <- data.frame(x1=c(1.8), y1=c(4), z1=c(2),
                  x2=c(1.8), y2=c(4), z2=c(4.5))
triangles <- data.frame(x1=c(2,2), y1=c(3,3), z1=c(0,2),
                       x2=c(1,1), y2=c(5,5), z2=c(0,2),
                       x3=c(2,2), y3=c(4,4), z3=c(0,2))
o <- as.numeric(ray[1,1:3])
d <- as.numeric(ray[1,4:6]) - o
# Replicate ray to match the number of triangles:
o <- rbind(o, o)
d <- rbind(d, d)
# Prepare triangle data:
v0 <- as.matrix(triangles[,1:3])
v1 <- as.matrix(triangles[,4:6])
v2 <- as.matrix(triangles[,7:9])
# Set epsilon value:
epsilon <- .Machine$double.eps
trace_ray(o, d, v0, v1, v2, epsilon)

}
